#include "stdafx.h"
#pragma comment(linker, "/STACK:10000000")
#pragma comment(linker, "/HEAP:10000000")
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <iostream>
#include <fstream>
#include <opencv2/features2d.hpp>
#include <opencv2/xfeatures2d.hpp>

using namespace cv;
using namespace std;



int main(int argc, char** argv)
{
	//Zmienne
	const unsigned int rozm = 4;
	Mat image;
	Mat image_r;
	int CorHor = 5;
	int CorVer = 15;
	Size size(CorHor, CorVer);
	vector <Point2f> outputarray;
	vector <Point2f> outputarray_r;
	vector <Point2f> corners;
	string frame;
	string frame_r;
	vector<Point3f> obj;
	Mat intrinsic = Mat(3, 3, CV_32FC1);
	Mat distCoeffs;
	Mat distCoeffs_r;
	Mat imageUndistorted;
	vector<Mat> rvecs;
	vector<Mat> tvecs;
	vector<vector<Point3f>> object_points;
	vector<vector<Point2f>> image_points;
	vector<vector<Point2f>> image_points_r;
	int lost = 0;
	int licz = 0;
	for (int i = 0; i < CorVer; i++)
	{
		for (int j = 0; j < CorHor; j++)
		{
			obj.push_back(Point3f((2 * j + i % 2) * 128, i * 128, 0.0f));
		}
	}
	//Algorytm
	licz = 1;

	for (int i = 0; i < rozm; i++)
	{
		system("cls");
		frame = "C:/Users/Grafika Multimedia/source/repos/test1/test1/conventered/1/img" + to_string(i) + ".jpg";
		frame_r = "C:/Users/Grafika Multimedia/source/repos/test1/test1/conventered/2/img" + to_string(i) + ".jpg";
		image = imread(frame, IMREAD_GRAYSCALE);
		image_r = imread(frame_r, IMREAD_GRAYSCALE);
		cout << i + 1 << "/" << rozm << endl;
		//cout << "pomineto " << lost << endl;
		if ((findCirclesGrid(image, size, outputarray, CALIB_CB_ASYMMETRIC_GRID) && findCirclesGrid(image_r, size, outputarray_r, CALIB_CB_ASYMMETRIC_GRID)))
		{
			//cornerSubPix(image, outputarray, Size(5, 5), Size(-1, -1), TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, 1e-6));
			//cornerSubPix(image_r, outputarray_r, Size(5, 5), Size(-1, -1), TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, 1e-6));

			/*if (abs(sqrt(pow(corners.at(0).x, 2) + pow(corners.at(0).y, 2)) - sqrt(pow(outputarray.at(0).x, 2) + pow(outputarray.at(0).y, 2))) > 15.0f ||
			abs(sqrt(pow((corners.at(0).x - corners.back().x), 2) + pow((corners.at(0).y - corners.back().y), 2)) - sqrt(pow((outputarray.at(0).x - outputarray.back().x), 2) + pow((outputarray.at(0).y - outputarray.back().y), 2))) > 10.0f ||
			abs(sqrt(pow((corners.at(9).x - corners.at(59).x), 2) + pow((corners.at(9).y - corners.at(59).y), 2)) - sqrt(pow((outputarray.at(9).x - outputarray.at(59).x), 2) + pow((outputarray.at(9).y - outputarray.at(59).y), 2))) > 10.0f)
			{*/
			image_points.push_back(outputarray);
			image_points_r.push_back(outputarray_r);
			object_points.push_back(obj);
			corners = outputarray;
			
		}
		//}
		//else
		{
			lost++;

		}
		
	}

	//Macierz
	intrinsic.ptr<float>(0)[0] = 1.11510032e+03f;
	intrinsic.ptr<float>(0)[1] = 0.0f;
	intrinsic.ptr<float>(0)[2] = 5.99616631e+02f;
	intrinsic.ptr<float>(1)[0] = 0.0f;
	intrinsic.ptr<float>(1)[1] = 1.14168758e+03f;
	intrinsic.ptr<float>(1)[2] = 5.05226607e+02f;
	intrinsic.ptr<float>(2)[0] = 0.0f;
	intrinsic.ptr<float>(2)[1] = 0.0f;
	intrinsic.ptr<float>(2)[2] = 1.0f;

	Mat in = Mat(3, 3, CV_32FC1);

	Mat image_l;
	image_l = imread("C:/Users/Grafika Multimedia/source/repos/test1/test1/conventered/1/img4.jpg", IMREAD_GRAYSCALE);
	//Mat image_r;
	image_r = imread("C:/Users/Grafika Multimedia/source/repos/test1/test1/conventered/2/img4.jpg", IMREAD_GRAYSCALE);

	//Kalibracja i undistorsja
	fstream plik;
	plik.open("logs.txt", ios::in | ios::out);
	if (plik.good() == true)
	{
		cout << "Uzyskano dostep do pliku!" << std::endl;
		//tu operacje na pliku
	}
	else cout << "Dostep do pliku zostal zabroniony!" << endl;

	/*cout << "calibracja lewa" << endl;
	cout << calibrateCamera(object_points, image_points, image_l.size(), intrinsic, distCoeffs, rvecs, tvecs, 0, TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)) << endl; //lewo
	cout << "calibracja prawa" << endl;
	cout << calibrateCamera(object_points, image_points_r, image_r.size(), intrinsic, distCoeffs_r, rvecs, tvecs, 0, TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)) << endl; //prawa

	Mat R, T, E, F, error, outi;

	cout << "calibracja stereo" << endl;
	cout << stereoCalibrate(object_points, image_points, image_points_r, intrinsic, distCoeffs, intrinsic, distCoeffs_r, image_l.size(), R, T, E, F, error, CALIB_FIX_INTRINSIC + CALIB_USE_INTRINSIC_GUESS + CALIB_FIX_K1 + CALIB_FIX_K2 + CALIB_FIX_K3 + CALIB_FIX_K4 + CALIB_FIX_K5, TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, 1e-6)) << endl;

	cout << T;

	cout << R;

	cout << distCoeffs;

	cout << distCoeffs_r;

	cout << intrinsic;
	*/
	Mat croppedImage_l = image_l(Rect(outputarray.at(0).x-100, outputarray.at(0).y-250, 400, 400));
	Mat croppedImage_r = image_r(Rect(outputarray_r.at(0).x-100, outputarray_r.at(0).y-250, 400, 400));

	Mat outi, outi_r, descriptor_l, descriptor_r, mask;
	vector<vector<DMatch>> matches;
	int k;
	vector< KeyPoint > kp;
	Ptr<FastFeatureDetector> fast = FastFeatureDetector::create();
	vector< KeyPoint > kp1;
	Ptr<FastFeatureDetector> fast1 = FastFeatureDetector::create();
	//fast->detect(image_l, kp);
	//fast1->detect(image_r, kp1);
	Ptr<AKAZE> akaze = AKAZE::create();
	
	//akaze->detectAndCompute(image_l, noArray(), kp, descriptor_l);
	//akaze->detectAndCompute(image_r, noArray(), kp1, descriptor_r);

	akaze->detectAndCompute(croppedImage_l, noArray(), kp, descriptor_l);
	akaze->detectAndCompute(croppedImage_r, noArray(), kp1, descriptor_r);

	//drawKeypoints(image_l, kp, outi);
	//drawKeypoints(image_r, kp1, outi_r);

	BFMatcher matcher(NORM_L2);
	matcher.knnMatch(descriptor_l, descriptor_r, matches,2);

	std::vector<DMatch> match1;
	std::vector<DMatch> match2;

	for (int i = 0; i<matches.size(); i++)
	{
		match1.push_back(matches[i][0]);
		match2.push_back(matches[i][1]);
	}

	Mat img_matches1, img_matches2;
	drawMatches(croppedImage_r, kp, croppedImage_l, kp1, match1, img_matches1);
	drawMatches(croppedImage_r, kp, croppedImage_l, kp1, match2, img_matches2);
	
	imshow("lewa", img_matches1);
	imshow("prawa", img_matches2);
	//imshow("lewa", croppedImage_l);
	//imshow("prawa", croppedImage_r);

	Mat imageUndistorted_l;
	Mat imageUndistorted_r;

	/*undistort(image_l, imageUndistorted_l, intrinsic, distCoeffs);
	undistort(image_r, imageUndistorted_r, intrinsic, distCoeffs_r);
	//WyÅ›wietlanie
	imshow("Display windowL", imageUndistorted_l);
	imshow("Display windowR", imageUndistorted_r);*/

	//cin.get();
	//cin.get();
	waitKey(0); // Wait for a keystroke in the window
	return 0;
