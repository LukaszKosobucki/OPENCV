#include "stdafx.h"
#pragma comment(linker, "/STACK:10000000")
#pragma comment(linker, "/HEAP:10000000")
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <iostream>
#include <fstream>

using namespace cv;
using namespace std;


static void refineSegments(const Mat& img, Mat& mask, Mat& dst);
//void przyspieszanko(VideoCapture video);
int main(int argc, char** argv)
{
	//Zmienne
	int lowerR = 192;
	int lowerG = 86;
	int lowerB = 93;
	int upperR = 255;
	int upperG = 255;
	int upperB = 255;

	int circleR = 124;
	int circleG = 252;
	int circleB = 0;
	namedWindow("Trackbar", WINDOW_FULLSCREEN);
	createTrackbar("Lower R", "Trackbar",&lowerR,255,NULL);
	createTrackbar("Lower G", "Trackbar",&lowerG, 255, NULL);
	createTrackbar("Lower B", "Trackbar",&lowerB, 255, NULL);
	createTrackbar("Upper R", "Trackbar", &upperR, 255, NULL);
	createTrackbar("Upper G", "Trackbar", &upperG, 255, NULL);
	createTrackbar("Upper B", "Trackbar", &upperB, 255, NULL);
	Mat frame, frame2;
	Mat hsv;
	Mat drone;
	VideoCapture video("drone.mp4");
	VideoCapture video2("drone.mp4");
	video.set(CAP_PROP_FPS, 60.0f);
	Mat lower_orange(217.0f, 97.0f, 54.0f);
	Mat upper_orange(255.05f, 103.0f, 38.0f);
	Mat mask, bgmask;
	Mat erodeElement = getStructuringElement(MORPH_RECT, Size(3, 3));
	Mat dilateElement = getStructuringElement(MORPH_RECT, Size(8, 8));
	vector< vector<Point> > contours;
	vector<Vec4i> hierarchy;
	bool objectFound = false;
	int iter = 0;


	while (1)
	{
		video.read(frame);
		if (frame.empty())
			break;
		cvtColor(frame, hsv, COLOR_RGB2HSV);
		inRange(hsv,Scalar(lowerB,lowerG,lowerR), Scalar (upperB, upperG, upperR),mask);
		erode(mask, mask, erodeElement);
		erode(mask, mask, erodeElement);
		dilate(mask, mask, dilateElement);
		dilate(mask, mask, dilateElement);
		
		findContours(mask, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE);
		bitwise_and(frame, frame, drone, mask);
		if (contours.empty())
		{
			;
		}
		else
		{
			
			circle(frame, Point(contours[0][0].x+5, contours[0][0].y+5), 7, Scalar(circleR, circleG, circleB ),2);
			//rectangle(frame, Point(contours[0][0].x, contours[0][0].y), Point(contours[0][0].x+15, contours[0][0].y+15), Scalar(150, 100, 50), 2);
		}
		//imshow("drone", drone);
		//imshow("disp2", hsv);
		//imshow("disp3", mask);
		imshow("disp", frame);
		contours.clear();
		iter++;
		char c = char(waitKey(1));
		if (c == 27)
			break;
		


	}
	
	waitKey(1); // Wait for a keystroke in the window
	return 0;
}

static void refineSegments(const Mat& img, Mat& mask, Mat& dst)
{
	int niters = 3;
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	Mat temp;
	dilate(mask, temp, Mat(), Point(-1, -1), niters);
	erode(temp, temp, Mat(), Point(-1, -1), niters * 2);
	dilate(temp, temp, Mat(), Point(-1, -1), niters);
	findContours(temp, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE);
	dst = Mat::zeros(img.size(), CV_8UC3);
	if (contours.size() == 0)
		return;
	// iterate through all the top-level contours,
	// draw each connected component with its own random color
	int idx = 0, largestComp = 0;
	double maxArea = 0;
	for (; idx >= 0; idx = hierarchy[idx][0])
	{
		const vector<Point>& c = contours[idx];
		double area = fabs(contourArea(Mat(c)));
		if (area > maxArea)
		{
			maxArea = area;
			largestComp = idx;
		}
	}
	Scalar color(0, 0, 255);
	drawContours(dst, contours, largestComp, color, FILLED, LINE_8, hierarchy);
}
